:mod:`citam.engine.io.input_parser`
===================================

.. py:module:: citam.engine.io.input_parser


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   citam.engine.io.input_parser._process_row
   citam.engine.io.input_parser.parse_csv_metadata_file
   citam.engine.io.input_parser.extract_buildings_elem
   citam.engine.io.input_parser.parse_standalone_svg_floorplan_file
   citam.engine.io.input_parser._load_buildings_data
   citam.engine.io.input_parser._extract_space_metadata
   citam.engine.io.input_parser._extract_spaces
   citam.engine.io.input_parser._extract_doors
   citam.engine.io.input_parser.parse_svg_floorplan_file
   citam.engine.io.input_parser.parse_meetings_policy_file
   citam.engine.io.input_parser.parse_scheduling_policy_file
   citam.engine.io.input_parser.parse_office_assignment_file
   citam.engine.io.input_parser.check_for_required_values
   citam.engine.io.input_parser.validate_input_values
   citam.engine.io.input_parser.validate_shifts
   citam.engine.io.input_parser.validate_traffic_policy
   citam.engine.io.input_parser.parse_input_file



Attributes
~~~~~~~~~~

.. autoapisummary::

   citam.engine.io.input_parser.LOG
   citam.engine.io.input_parser.UNABLE_TO_READ_FILE_STR


.. data:: LOG
   

   

.. data:: UNABLE_TO_READ_FILE_STR
   :annotation: = Could not read input file

   

.. exception:: MissingInputError


   Bases: :py:obj:`ValueError`

   Inappropriate argument value (of correct type).
















   ..
       !! processed by numpydoc !!


.. exception:: InvalidSVGError


   Bases: :py:obj:`ValueError`

   Inappropriate argument value (of correct type).
















   ..
       !! processed by numpydoc !!


.. function:: _process_row(header: List[str], row_id: int, row: List[str])

   Process row data from floorplan CSV file.

   :param header: List of header values.
   :type header: List[str]
   :param row_id: index of this row
   :type row_id: int
   :param row: row data as list of values
   :type row: List[str]
   :raises ValueError: if row has the wrong number of values.
   :raises ValueError: if required value(s) missing.
   :raises ValueError: if unrecoginzed space function is found.
   :return: row data as a dictionary with key taken from header
   :rtype: [type]















   ..
       !! processed by numpydoc !!


.. function:: parse_csv_metadata_file(csv_file: Union[str, pathlib.Path]) -> List[Dict[str, str]]

   Read and parse CSV floorplan metadata file with list of spaces and their
   attributes (id, function, etc.).

   :param csv_file: path to csv file.
   :type csv_file: Union[str, pathlib.Path]
   :raises FileNotFoundError: If CSV file is not found.
   :raises ValueError: If a required column is missing from file.
   :return: List of dictionaries (one dict per entry in the CSV file) with
           column headers as keys
   :rtype: List[Dict[str, str]]















   ..
       !! processed by numpydoc !!


.. function:: extract_buildings_elem(contents_elem: List[xml.etree.ElementTree.Element]) -> List[xml.etree.ElementTree.Element]

   Extract building elements from SVG contents

   :param contents_elem: The list of SVG elements with building info
   :type contents_elem: List[ET.Element]
   :raises InvalidSVGError: if no building elem found
   :return: List of building elements
   :rtype: List[ET.Element]















   ..
       !! processed by numpydoc !!


.. function:: parse_standalone_svg_floorplan_file(svg_file: Union[str, pathlib.Path]) -> Tuple[List[svgpathtools.Path], List[Dict[str, str]], List[svgpathtools.Path]]

   Read standalone svg input file to extract floorplan information. The SVG
   file should include and ID and a function for each space.

   :param svg_file: input file in SVG format to parse.
   :type svg_file: Union[str, pathlib.Path]
   :raises InvalidSVGError: If no element with id=contents is found
   :raises InvalidSVGError: If no element with class=floorplan is found.
   :raises InvalidSVGError: If no buildings were found (elements with
           id=spaces and id=doors)
   :return: Tuple with list of space paths, list of space attributes and
           list of door paths
   :rtype: Tuple[List[Path], List[Dict[str, str]], List[Path]]















   ..
       !! processed by numpydoc !!


.. function:: _load_buildings_data(contents_elem: List[xml.etree.ElementTree.Element]) -> Tuple[List[svgpathtools.Path], List[Dict[str, str]], List[svgpathtools.Path]]

   Given a SVG tree element with sub-elements with building information,
   extract data for each building and add to overall list of space paths,
   space attributes and doors for this floorplan.

   :param contents_elem: Element from the SVG file with data for each building
           as subelements.
   :type contents_elem: List[ET.Element]
   :raises InvalidSVGError: If no sub-element with class spaces were found.
   :return: tuple with list of space paths, list of space attributes and list
       of door paths.
   :rtype: Tuple[List[Path], List[Dict[str, str]], List[Path]]















   ..
       !! processed by numpydoc !!


.. function:: _extract_space_metadata(space_elem: xml.etree.ElementTree.Element, building_name: str) -> Dict[str, str]

   Extract data from space SVG element and return dictionary of values.

   :param space_elem: The space SVG element.
   :type space_elem: ET.Element
   :param building_name: Name of the building where this space is found.
   :type building_name: str
   :raises ValueError: if space ID or function is missing.
   :raises ValueError: if space function is invalid.
   :return: Dictionary with key-value pairs of space metadata.
   :rtype: Dict[str, str]















   ..
       !! processed by numpydoc !!


.. function:: _extract_spaces(spaces_elem: xml.etree.ElementTree.Element, building_name: str) -> Tuple[List[svgpathtools.Path], List[Dict[str, str]]]

   Given a SVG tree element, extract all space paths and attributes.

   :param spaces_elem: SVG element with each subelement representing a space.
   :type spaces_elem: ET.Element
   :param building_name: The name of the building
   :type building_name: str
   :raises ValueError: If the function assigned to the space is unknown.
   :raises ValueError: If the space path has no ID or function specified.
   :return: list of space paths and attributes.
   :rtype: Tuple[List[Path], List[Dict[str, str]]]















   ..
       !! processed by numpydoc !!


.. function:: _extract_doors(doors_elem: xml.etree.ElementTree.Element) -> List[svgpathtools.Path]

   Given a SVG tree element, extract all door paths.

   :param doors_elem: SVG element with each subelement representing a door.
   :type doors_elem: ET.Element
   :return: list of door paths.
   :rtype: List[Path]















   ..
       !! processed by numpydoc !!


.. function:: parse_svg_floorplan_file(svg_file: Union[str, pathlib.Path]) -> Tuple[List[svgpathtools.Path], List[Dict[str, str]], List[svgpathtools.Path]]

   Read and parse SVG floorplan file.

    Each space is represented by a path element with and id that matches the
   id in the csv file.

   :param svg_file: path to csv file
   :type svg_file: Union[str, pathlib.Path]
   :raises FileNotFoundError: If SVG file is not found.
   :return: List of path elements and their attributes as well as door paths.
   :rtype: Tuple[List[Path], List[Dict[str, str]], List[Path]]















   ..
       !! processed by numpydoc !!


.. function:: parse_meetings_policy_file(input_dict: dict) -> Optional[Dict[str, Union[int, str, float, dict]]]

   Read and parse the json meeting policy file if found in input dict.

   The meetings policy for a given facility exposes parameters
   for when, where, how often and how long meetings take place
   in the facility.

   :param input_dict: dictionary of inputs with path to meetings policy file.
   :type input_dict: dict
   :raises FileNotFoundError: IIf the file is not found.
   :return: data extracted from the file as a dictionary
   :rtype: Optional[Dict[str, Union[int, str, float, dict]]















   ..
       !! processed by numpydoc !!


.. function:: parse_scheduling_policy_file(input_dict: dict) -> Optional[Dict[str, Union[int, str, float, dict]]]

   Read and parse the json scheduling policy file if found in input dict.

   Together with the meetings policy file, this file encodes
   how and when people will be moving within a given facility.
   Scheduling policies revolve around the concept of "scheduling
   purpose" which ties them to a category of space in the floorplan.
   See the documentation for more information.

   :param input_dict: dictionary with path to scheduling policy file.
   :type input_dict: dict
   :raises FileNotFoundError: [description]
   :return: data extracted from the file as a dictionary.
   :rtype: Optional[Dict[str, Union[int, str, float, dict]]]















   ..
       !! processed by numpydoc !!


.. function:: parse_office_assignment_file(input_dict: dict) -> Optional[List[Tuple[int, int]]]

   Read and parse office assignment file if found in input dic.

   :param input_dict: dictionary with path to office assignment file.
   :type input_dict: dict
   :raises exception: if unable to read file
   :raises ValueError: if invalid values are found in assignment file.
   :return: office space ID and floor number assigned to each agent.
   :rtype: Optional[List[Tuple[int, int]]]















   ..
       !! processed by numpydoc !!


.. function:: check_for_required_values(input_dict: dict) -> None

   Verify that all required values are found in the input dict.

   :param input_dict: dictionary of inputs
   :type input_dict: dict
   :raises MissingInputError: if a required value is missing















   ..
       !! processed by numpydoc !!


.. function:: validate_input_values(facility_name: str, floors: List[int], n_agents: int, daylength: int, entrances: List[dict], buffer: int) -> None

   Verify that input values are of the correct type and have valid values.

   :param facility_name: Name of the facility of interest.
   :type facility_name: str
   :param floors: List of floors for this simulation
   :type floors: List[int]
   :param n_agents: Number of agents in this simulation
   :type n_agents: int
   :param daylength: duration of the simulaiton
   :type daylength: int
   :param entrances: Entrances available for agents to enter the facility
   :type entrances: List[dict]
   :param buffer: when do agents start entering the facility.
   :type buffer: int
   :raises TypeError: if any input value is of the wrong type
   :raises ValueError: if invalid input values are found.















   ..
       !! processed by numpydoc !!


.. function:: validate_shifts(shifts: List[dict]) -> None

   Validate input values for shifts. A shift is a group of agents who enter
   the facility at the same time.

   :param shifts: List of shifts
   :type shifts: List[dict]
   :raises TypeError: if shifts is not a list.
   :raises ValueError: if shift does not define a name, start time and percent
       agents.
   :raises TypeError: if percent agents is not a number
   :raises ValueError: if percent agents is not a number between 0.0 and 1.0.















   ..
       !! processed by numpydoc !!


.. function:: validate_traffic_policy(traffic_policy)


.. function:: parse_input_file(input_file: Union[str, pathlib.Path]) -> Dict[str, Any]

   Read primary simulation input file in json format, validate values,
   load floorplans and returns dictionary of model inputs.

   :param input_file: path to input file expected in json format
   :type input_file: Union[str, pathlib.Path]
   :raises ValueError: If unable to decode JSON file.
   :raises FileNotFoundError: If the file is not found.
   :raises MissingInputError: If a required value is not found
   :raises TypeError: If incorrect value type is found for one or more inputs.
   :raises ValueError: If an input value is invalid.
   :raises FileNotFoundError: If path to another to a meetings policy is file
           is not valid.
   :raises FileNotFoundError: If path to another to a scheduling policy is
           file is not valid.
   :return: dictionary of inputs
   :rtype: Dict[str, Any]















   ..
       !! processed by numpydoc !!


