:py:mod:`citam.engine.map.ingester`
===================================

.. py:module:: citam.engine.map.ingester

.. autoapi-nested-parse::

   
   ..
       !! processed by numpydoc !!


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   citam.engine.map.ingester.FloorplanIngester



Functions
~~~~~~~~~

.. autoapisummary::

   citam.engine.map.ingester.find_invalid_walls
   citam.engine.map.ingester.check_for_overlap_with_other_walls



Attributes
~~~~~~~~~~

.. autoapisummary::

   citam.engine.map.ingester.LOG


.. py:data:: LOG
   

   
















   ..
       !! processed by numpydoc !!

.. py:class:: FloorplanIngester(svg_file: Union[str, pathlib.Path], scale: float, csv_file: Union[str, pathlib.Path] = None, extract_doors_from_file: bool = False, buildings_to_keep: Set[str] = None, excluded_buildings: Set[str] = None)

   
   Ingest floorplan data from svg and csv files.
















   ..
       !! processed by numpydoc !!
   .. py:method:: create_spaces_from_csv_and_svg_data(self) -> None

      
      Create space objects from data extracted in csv and svg files
















      ..
          !! processed by numpydoc !!

   .. py:method:: create_spaces_from_svg_data(self) -> None

      
      Create space objects from data extracted in standalone svg file
















      ..
          !! processed by numpydoc !!

   .. py:method:: validate_buildings(self) -> None

      
      Make sure we take all user-provided building names into account
















      ..
          !! processed by numpydoc !!

   .. py:method:: read_data_from_svg_file(self) -> None

      
      Read and parse floorplan from svg file
















      ..
          !! processed by numpydoc !!

   .. py:method:: read_data_from_csv_and_svg_files(self) -> None

      
      Read and parse csv and svg files
















      ..
          !! processed by numpydoc !!

   .. py:method:: read_input_files(self) -> None

      
      Read and parse csv and svg files
















      ..
          !! processed by numpydoc !!

   .. py:method:: run(self) -> None

      
      Perform the ingestion process
















      ..
          !! processed by numpydoc !!

   .. py:method:: find_space_index_for_door(self, door: svgpathtools.Path) -> Tuple[Optional[int], List[svgpathtools.Line]]

      
      Given a door SVG element, find the index of the space to which it
      belongs.

      :param door: path element representing a door in the drawing
      :type: Door
      :return: space_index and door lines
      :rtype: (int,list[Line])















      ..
          !! processed by numpydoc !!

   .. py:method:: find_closest_wall_and_best_door_line(self, space_index: int, door_lines: List[svgpathtools.Line], max_distance=10.0) -> Tuple[Optional[int], Optional[svgpathtools.Line]]

      
      Given a number of lines in the door SVG element, find the best line
      based on proximity to a wall.

      :param space_index: index of the space where this door is located.
      :type space_index: int
      :param door_lines: list of Line elements that represent the door
      :type door_lines: List[Line]
      :param max_distance: max distance beyond which a wall is considered too
           far from the door., defaults to 10.0
      :type max_distance: float, optional
      :return: The index of the space and the best door line
      :rtype: Tuple[Optional[int], Optional[Line]]















      ..
          !! processed by numpydoc !!

   .. py:method:: _find_all_overlapping_walls(self, door_line: svgpathtools.Line) -> Dict[int, List[int]]

      
      Given a door line, find all overlapping walls.

      :param door_line: Line representing the door
      :type door_line: Line
      :return: Dictionary with all the overallping walls.
      :rtype: Dict[int, List[int]]















      ..
          !! processed by numpydoc !!

   .. py:method:: build_door_line(self, door: svgpathtools.Path) -> svgpathtools.Line

      
      Take a door path (Line or Bezier Curve) and return a Line that
      corresponds to where it acutally falls on the map based on
      overlap with existing walls.

      :param door: The door path
      :type door: Path
      :return: The best line to represent the door.
      :rtype: Line















      ..
          !! processed by numpydoc !!

   .. py:method:: _create_door_object(self, door_line: svgpathtools.Line, space_indices: List[int]) -> None

      
      Given a door line and space indices, create new door object and add it
      to the list of doors for this floorplan.

      :param door_line: The door line of interest.
      :type door_line: Line
      :param space_indices: Indices of the spaces that this door connects
      :type space_indices: List[int]















      ..
          !! processed by numpydoc !!

   .. py:method:: _remove_door_from_overlapping_walls(self, door_line: svgpathtools.Line, overlapping_walls: Dict[int, List[int]]) -> None

      
      Given a door line and a dict of overlapping walls grouped by their
      corresponding space index, carve out the door in each wall and update
      walls accordingly.

      :param door_line: The door line.
      :type door_line: Line
      :param overlapping_walls: A dictionary of overlapping walls.
      :type overlapping_walls: Dict[int, List[int]]















      ..
          !! processed by numpydoc !!

   .. py:method:: process_doors(self) -> None

      
      Iterate over the door paths extracted from the SVG file, find
      associated spaces and create door objects.
















      ..
          !! processed by numpydoc !!

   .. py:method:: create_new_door_to_room(self, room_wall: svgpathtools.Line, room_id: int) -> None

      
      Add door to access a given room from a given wall.

      :param room_wall: the wall to carve out the door from.
      :type room_wall: Line
      :param room_id: index of the room of interest.
      :type room_id: int















      ..
          !! processed by numpydoc !!

   .. py:method:: check_for_overlap_with_other_walls_and_add_door_to_wall(self, h_wall: svgpathtools.Line, other_walls: List[svgpathtools.Line], other_space_ids: List[int], add_door: bool) -> Optional[List[svgpathtools.Line]]

      
      Check for overlap between a given wall and all other walls in facility
      and add door if overlap exists with room wall that has no door.
















      ..
          !! processed by numpydoc !!

   .. py:method:: find_and_remove_overlaps_between_walls(self, hallway_wall: svgpathtools.Line, other_walls: List[svgpathtools.Line], other_space_ids: List[int], add_door=True) -> List[svgpathtools.Line]

      
      Given a hallway wall, iterate over all other walls to test for overlap.
      If found, remove overlap.

      :param hallway_wall: Line representing one of the walls
      :type hallway_wall: Line
      :param other_walls: list of other walls from which to look for overlap
           with this wall
      :type other_walls: List[Line]
      :param other_space_ids: list of indices of the space to which each wall
           belongs
      :type other_space_ids: List[int]
      :param add_door: Whether to add doors to the wall or not,
           defaults to True
      :type add_door: bool, optional
      :return: The list of wall fragments after removing overlaps.
      :rtype: List[Line]















      ..
          !! processed by numpydoc !!

   .. py:method:: get_building_walls(self, building: str) -> Tuple[list, list, list, list]

      
      Extract all walls from building and return the room walls and hallway
      walls seperately.

      :param building: The name of the building
      :type building: str
      :return: List of room indices and walls as well as hallway indices
          and walls.
      :rtype: Tuple[list, list, list, list]















      ..
          !! processed by numpydoc !!

   .. py:method:: find_valid_walls_and_create_doors(self, building: str) -> Tuple[List[svgpathtools.Line], List[svgpathtools.Line]]

      
      Remove all invalid walls, create missing doors and return the remaining
      walls.

      :param building: The name of the building.
      :type building: str
      :return: The list of all rooms and the list of the valid ones.
      :rtype: Tuple[List[Line], List[Line]]















      ..
          !! processed by numpydoc !!

   .. py:method:: get_floorplan(self)

      
      Return the ingested floorplan object.
















      ..
          !! processed by numpydoc !!

   .. py:method:: find_min_and_max_coordinates(self)

      
      Find the min and max coordinates for both x and y.
















      ..
          !! processed by numpydoc !!


.. py:function:: find_invalid_walls(hallway_walls: List[svgpathtools.Line]) -> Tuple[List[svgpathtools.Line], List[svgpathtools.Line]]

   
   Find and remove any wall that seperates 2 hallways (or aisles).

               Remove this wall
                       |
                       V

   --------------------|------------------
       hallway 1       |   hallway 2
   --------------------|------------------

   :param hallway_walls: list of lines representing the walls to check.
   :type hallway_walls: List[Line]
   :return: list of valid walls and list of invalid_hallway_walls
   :rtype: Tuple[List[Line], List[Line]]















   ..
       !! processed by numpydoc !!

.. py:function:: check_for_overlap_with_other_walls(wall_index: int, hallway_walls: List[svgpathtools.Line], invalid_hallway_walls: List[svgpathtools.Line]) -> None

   
   Given hallway wall at index wall_index, iterate over all hallway walls and
   check for overlap. If there is overlap, update list of invalid hallways.

   :param wall_index: Index of the wall of interest.
   :type wall_index: int
   :param hallway_walls: The list of all hallway walls.
   :type hallway_walls: List[Path
   :param invalid_hallway_walls: The list of invalid hallway walls.
   :type invalid_hallway_walls: List[Path]















   ..
       !! processed by numpydoc !!

